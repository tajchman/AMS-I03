\include{debut}

\begin{document}
%    \layout
    
    \begin{center}
    	\LARGE TP 8. Programmation des GPU avec Cuda (suite)
    \end{center}

	\section*{Préparation}
    
    Récupérer l'archive compressée {\tt TP8.tar.gz} et extraire les fichiers qui sont contenus dans cette archive.
    
  	Se placer dans le répertoire {\tt TP8}:
    \begin{script}
        cd TP8
    \end{script}

    et préparer les compilations dans les points suivants avec la commande ci-dessous:
    \begin{script}
        ./build.sh
    \end{script}
	
\section{Traitement d'image}

Il s'agit de générer à partir d'une image couleur d'origine, une autre en nuances de gris où les contours sont mis en avant.
\smallskip

On fournit un code séquentiel (dans \texttt{src/cpu/sequential})  pour processeur CPU qui effectue les opérations suivantes:

\begin{itemize}
	\item Lecture de l'image d'origine
	\item Génération d'une image en nuances de gris
	\item Application d'un filtre gaussien pour obtenir une image plus régulière
	\item Application d'un filtre de Sobel (calcul de la valeur absolue approchée du gradient en chaque pixel), pour obtenir une image (en nuances de gris) où les contours sont renforcés.
	\item Enregistrement de cette dernière image dans un fichier.
\end{itemize}

(une version OpenMP est également fournie pour comparaison de performances).

\smallskip
La compilation avec build.sh fournit les exécutables \texttt{./install/image\_cpu} et \\ \texttt{./install/image\_cpu\_openmp} qu'il suffit d'exécuter sans paramètres, pour traiter par défault l'image dans le fichier \texttt{./install/ecureuil.png}.

\smallskip
Après exécution du code, le fichier qui contient le résultat est dans \texttt{./install/res\_ecureuil.png}.

\smallskip
Afficher ces deux fichiers.

\begin{question}
   Comparer les temps d'exécution de la version séquentielle et de la version parallélisée avec OpenMP.
   
   Les temps sont affichés séparément pour les parties lecture et écriture sur fichier et l'application de chaque filtre.
\end{question}

\section{Version GPU (Cuda) du code}

Dans le répertoire \texttt{./src/gpu/cuda}, un code partiellement écrit sera chargé de faire le même calcul sur GPU (type Nvidia) avec Cuda.

Ce qui est déjà écrit~:
\begin{itemize}
	\item la structure \texttt{cImage} (dans le fichier \texttt{src/common/cImage.h}) pour représenter les données d'une image pour le CPU. 
	
	Ce fichier contient aussi les fonctions de lecture et d'écriture dans des fichiers.

	\item la structure \texttt{cImageGPU} (dans le fichier \texttt{src/gpu/cuda/cImageGPU.h}) pour représenter les données d'une image pour le GPU. Si \texttt{I} est de type \texttt{cImageGPU}
\begin{itemize}
	\item \texttt{I.width} est le nombre de pixels sur une ligne
	\item \texttt{I.height} est le nombre de pixels sur une colonne
	\item \texttt{I.d\_coeff[0]} est un vecteur des composantes rouges,
	\texttt{I.d\_coeff[1]} les composantes vertes et \texttt{I.d\_coeff[2]} les composantes bleues de l'image couleur. 
	\item \texttt{I.d\_coeff[0]} les composantes de gris pour une image grisée.
\end{itemize}
	(les vecteurs \texttt{I.d\_coeff[k]} sont déjà sur GPU)
	
	Dans ce fichier sont déjà codés les appels de cudaMalloc et de cudaMemcpy pour réserver la mémoire sur le GPU et les transferts entre mémoires du GPU et du CPU.
	
	\item Le fichier \texttt{./build.sh} et les fichiers \texttt{CMakeLists.txt} qui compilent aussi la version cuda

	\item Les noyaux de calcul copyImageGPU (copie entre 2 structures dans le GPU) et smoothGPU (filtre régularisant) dans le fichier \texttt{src/gpu/cuda/process.cu}.
\end{itemize}
   
\begin{question}
Écrire les noyaux {\tt setGreyGPU} et {\tt sobelGPU} en reprenant les formules dans les fonctions analogues pour le CPU dans \texttt{src/cpu/sequential/process.cxx}.

On pourra s'inspirer des autres noyaux déjà écrits dans le même fichier et d'autres vus au cours.
\end{question}

   


\end{document}
