<html>
<head>
<link href="ihpsc.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$']]}
  });
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
  </script>

  <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<script type="application/javascript" src="http://ccrs.cac.cornell.edu:8080//ace/ace.js" charset="utf-8"></script>
<script type="application/javascript" src="http://ccrs.cac.cornell.edu:8080//target/web-client-jsdeps.js"></script>
<!-- include application -->
<script type="application/javascript" src="http://ccrs.cac.cornell.edu:8080//target/web-client-opt.js"></script>

<script type="application/javascript">
  // First we declare some metadata, primarily to describe
  // the container environment.
  var ccrsApiNamespace = "org.xsede.jobrunner.model.ModelApi";
  var mpiExampleMetaJson = {
    // CHANGE: for now, leave the appended string as .SysJobMetaData;
    //         other options will be supported in the future
    "$type": ccrsApiNamespace + ".SysJobMetaData",
    // CHANGE: shell to use implicitly when running commands in the container
    "shell": ["bash"],
    // CHANGE: should currently be one of: .NixOS, .Singularity
    "containerType": {
      "$type":  ccrsApiNamespace + ".NixOS"
    },
    // CHANGE: Specify for NixOS for all jobs, or for Singularity when resuming existing jobs
    "containerId": ["vicOpenMPI"],
    // CHANGE: Specify the singularity image name
    "image": [],
    // Directories on the host to mount in the container, if any:
    "binds": [],
    // Only for singularity:
    "overlay": [],
    // CHANGE: should be filled in dynamically to contain the (student) user,
    //         but this is a demo, so we use a static user name:
    "user": "test0",
    "address": [],
    "hostname": [],
    "url": window.location.href
  };
  var mpiExampleMeta = CCRS.sysJobMetaData(mpiExampleMetaJson);
</script>

<div class="container">
  <div class="row">
    <div class="col-12">
      <div class="pagehead">
        <h1>OpenMP remaining topics</h1>
        <h5>Experimental html version of downloadable textbook, see http://www.tacc.utexas.edu/~eijkhout/istc/istc.html</h5>
      </div>
    </div>
  </div>
  <div>


\[
\newcommand\inv{^{-1}}\newcommand\invt{^{-t}}
\newcommand\bbP{\mathbb{P}}
\newcommand\bbR{\mathbb{R}}
\newcommand\defined{
  \mathrel{\lower 5pt \hbox{${\equiv\atop\mathrm{\scriptstyle D}}$}}}
\]


26.1 : <a href="openmp.html#Runtimefunctionsandinternalcontrolvariables">Runtime functions and internal control variables</a><br>
26.2 : <a href="openmp.html#Timing">Timing</a><br>
26.3 : <a href="openmp.html#Threadsafety">Thread safety</a><br>
26.4 : <a href="openmp.html#Performanceandtuning">Performance and tuning</a><br>
26.5 : <a href="openmp.html#Accelerators">Accelerators</a><br>
<a href="index.html">Back to Table of Contents</a>
<h1>26 OpenMP remaining topics</h1>
<!-- TranslatingLineGenerator file ['file'] -->
<p name="switchToTextMode">

<h2><a id="Runtimefunctionsandinternalcontrolvariables">26.1</a> Runtime functions and internal control variables</h2>
<p name=crumbs>
crumb trail:  > <a href="openmp.html">openmp</a> > <a href="openmp.html#Runtimefunctionsandinternalcontrolvariables">Runtime functions and internal control variables</a>
</p>

<!-- index -->
<!-- index -->
<!-- index -->
</p>

<p name="switchToTextMode">
OpenMP has a number of settings that can be set through 
<i>environment variables</i>
,
and both queried and set through 
<i>library routines</i>
. These settings are called
\emph{ \acfp{ICV}
}: an OpenMP implementation behaves as if there is an internal variable
storing this setting.
</p>

<p name="switchToTextMode">
The runtime functions are:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
Counting threads and cores: 
<i>omp_set_num_threads</i>
,
<i>omp_get_num_threads</i>
,
<i>omp_get_max_threads</i>
, 
<i>omp_get_num_procs</i>
;
  see section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/omp-basics.html#Creatingparallelism">15.5</a>
.
<li>
Querying the current thread: 
<i>omp_get_thread_num</i>
, 
<i>omp_in_parallel</i>
<li>
<i>omp_set_dynamic</i>
<li>
<i>omp_get_dynamic</i>
<li>
<i>omp_set_nested</i>
<li>
<i>omp_get_nested</i>
<li>
<i>omp_get_wtime</i>
<li>
<i>omp_get_wtick</i>
<li>
<i>omp_set_schedule</i>
<li>
<i>omp_get_schedule</i>
<li>
<i>omp_set_max_active_levels</i>
<li>
<i>omp_get_max_active_levels</i>
<li>
<i>omp_get_thread_limit</i>
<li>
<i>omp_get_level</i>
<li>
<i>omp_get_active_level</i>
<li>
<i>omp_get_ancestor_thread_num</i>
<li>
<i>omp_get_team_size</i>
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

Here are the OpenMP 
<i>environment variables</i>
:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
<i>OMP_CANCELLATION</i>
 Set whether cancellation is activated
<li>
<i>OMP_DISPLAY_ENV</i>
 Show OpenMP version and environment variables
<li>
<i>OMP_DEFAULT_DEVICE</i>
 Set the device used in target regions
<li>
<i>OMP_DYNAMIC</i>
 Dynamic adjustment of threads
<li>
<i>OMP_MAX_ACTIVE_LEVELS</i>
 Set the maximum number of nested parallel
  regions
<li>
<i>OMP_MAX_TASK_PRIORITY</i>
 Set the maximum task priority value
<li>
<i>OMP_NESTED</i>
 Nested parallel regions
<li>
<i>OMP_NUM_THREADS</i>
 Specifies the number of threads to use
<li>
<i>OMP_PROC_BIND</i>
 Whether theads may be moved between CPUs
<li>
<i>OMP_PLACES</i>
 Specifies on which CPUs the theads should be placed
<li>
<i>OMP_STACKSIZE</i>
 Set default thread stack size
<li>
<i>OMP_SCHEDULE</i>
 How threads are scheduled
<li>
<i>OMP_THREAD_LIMIT</i>
 Set the maximum number of threads
<li>
<i>OMP_WAIT_POLICY</i>
 How waiting threads are
  handled; 
<span title="acronym" ><i>ICV</i></span>
<i>wait-policy-var</i>
. Values:
  
<tt>ACTIVE</tt>
 for keeping threads spinning, 
<tt>PASSIVE</tt>
 for possibly
  yielding the processor when threads are waiting.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

There are 4 
<span title="acronym" ><i>ICVs</i></span>
 that behave as if each thread has its own copy of them.
The default is implementation-defined unless otherwise noted.
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
It may be possible to adjust dynamically the number of threads
    for a parallel region. Variable: 
<i>OMP_DYNAMIC</i>
;
    routines: 
<i>omp_set_dynamic</i>
,
<i>omp_get_dynamic</i>
.
<li>
If a code contains 
<i>nested parallel regions</i>
,
    the inner regions may create new teams, or they may be executed by
    the single thread that encounters them. Variable:
<i>OMP_NESTED</i>
; routines 
<i>omp_set_nested</i>
,
<i>omp_get_nested</i>
. Allowed values are 
<tt>TRUE</tt>
 and
    
<tt>FALSE</tt>
; the default is false.
<li>
The number of threads used for an encountered parallel region
    can be controlled. Variable: 
<i>OMP_NUM_THREADS</i>
;
    routines 
<i>omp_set_num_threads</i>
,
<i>omp_get_max_threads</i>
.
<li>
The schedule for a parallel loop can be set. Variable:
<i>OMP_SCHEDULE</i>
; routines
<i>omp_set_schedule</i>
, 
<i>omp_get_schedule</i>
.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

Non-obvious syntax:
<!-- environment: verbatim start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=verbatim ]] -->
<verbatim>
<pre>
export OMP_SCHEDULE="static,100"
</pre>
</verbatim>
<!-- environment: verbatim end embedded generator -->
<p name="switchToTextMode">

Other settings:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
<i>omp_get_num_threads</i>
: query the number of threads
  active at the current place in the code; this can be lower than what
  was set with 
<i>omp_set_num_threads</i>
. For a meaningful answer, this
  should be done in a parallel region.
<li>
<i>omp_get_thread_num</i>
<li>
<i>omp_in_parallel</i>
: test if you are in a parallel
  region (see for instance section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/omp-basics.html#Creatingparallelism">15.5</a>
).
<li>
<i>omp_get_num_procs</i>
: query the physical number of cores available.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

Other environment variables:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
<i>OMP_STACKSIZE</i>
 controls the amount of space that is
  allocated as per-thread 
<i>stack</i>
; the space for private
  variables.
<li>
<i>OMP_WAIT_POLICY</i>
 determines the behaviour of
  threads that wait, for instance for 
<i>critical section</i>
:
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>

<tt>ACTIVE</tt>
 puts the thread in a 
<i>spin-lock</i>
, where
    it actively checks whether it can continue;
<li>

<tt>PASSIVE</tt>
 puts the thread to sleep until the 
<span title="acronym" ><i>OS</i></span>
 wakes
    it up.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">
  The `active' strategy uses CPU while the thread is waiting; on the
  other hand, activating it after the wait is instantaneous. With the
  `passive' strategy, the thread does not use any CPU while waiting,
  but activating it again is expensive. Thus, the passive strategy
  only makes sense if threads will be waiting for a (relatively) long
  time.
<li>
<i>OMP_PROC_BIND</i>
 with values 
<tt>TRUE</tt>
 and 
<tt>FALSE</tt>

  can bind threads to a processor. On the one hand, doing so can
  minimize data movement; on the other hand, it may increase load
  imbalance.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

<!-- index -->
<!-- index -->
<!-- index -->
</p>

<h2><a id="Timing">26.2</a> Timing</h2>
<p name=crumbs>
crumb trail:  > <a href="openmp.html">openmp</a> > <a href="openmp.html#Timing">Timing</a>
</p>

<p name="switchToTextMode">

OpenMP has a wall clock timer routine 
<i>omp_get_wtime</i>
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
double omp_get_wtime(void);
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
The starting point is arbitrary and is different for each program run;
however, in one run it is identical for all threads.
This timer has a resolution given by 
<i>omp_get_wtick</i>
.
</p>

<!-- environment: exercise start embedded generator -->
<!-- environment block purpose: [[ environment=exercise ]] -->
<exercise>
<b>Exercise</b>
<p name="exercise">
<!-- TranslatingLineGenerator exercise ['exercise'] -->
  Use the timing routines to demonstrate speedup from using
  multiple threads.
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
Write a code segment that takes a measurable amount of time, that is,
    it should take a multiple of the tick time.
<li>
Write a parallel loop and measure the speedup. You can for instance do this
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
for (int use_threads=1; use_threads&lt;=nthreads; use_threads++) {
#pragma omp parallel for num_threads(use_threads)
    for (int i=0; i&lt;nthreads; i++) {
        .....
    }
    if (use_threads==1)
      time1 = tend-tstart;
    else // compute speedup
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<li>
In order to prevent the compiler from optimizing your loop away, let
  the body compute a result and use a reduction to preserve these results.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
</exercise>
<!-- environment: exercise end embedded generator -->
<p name="switchToTextMode">

<h2><a id="Threadsafety">26.3</a> Thread safety</h2>
<p name=crumbs>
crumb trail:  > <a href="openmp.html">openmp</a> > <a href="openmp.html#Threadsafety">Thread safety</a>
</p>
<!-- index -->
</p>

<p name="switchToTextMode">
With OpenMP it is relatively easy to take existing code and make
it parallel by introducing parallel sections. If you're careful
to declare the appropriate variables shared and private,
this may work fine. However, your code may include
calls to library routines that include a 
<i>race condition</i>
;
such code is said not to be 
<i>thread-safe</i>
.
</p>

<p name="switchToTextMode">
For example a routine
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
static int isave;
int next_one() {
 int i = isave;
 isave += 1;
 return i;
}


...
for ( .... ) {
  int ivalue = next_one();
}
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
has a clear race condition, as the iterations of the loop
may get different 
<tt>next_one</tt>
 values, as they are supposed to,
or not. This can be solved by using an 
<tt>critical</tt>
pragma for the 
<tt>next_one</tt>
 call; another solution
is to use an 
<tt>threadprivate</tt>
 declaration for 
<tt>isave</tt>
.
This is for instance the right solution if  the 
<tt>next_one</tt>

routine implements a 
<i>random number generator</i>
.
</p>

<!-- index -->
<p name="switchToTextMode">

<h2><a id="Performanceandtuning">26.4</a> Performance and tuning</h2>
<p name=crumbs>
crumb trail:  > <a href="openmp.html">openmp</a> > <a href="openmp.html#Performanceandtuning">Performance and tuning</a>
</p>
</p>

<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/bibliography.html#epcc-ompbench">[epcc-ompbench]</a>
<p name="switchToTextMode">
.
</p>

<p name="switchToTextMode">
The performance of an OpenMP code can be influenced by the following.
</p>

<!-- environment: description start embedded generator -->
<!-- environment block purpose: [[ environment=description ]] -->
<description>
<ul>
<!-- TranslatingLineGenerator description ['description'] -->
<li>
[Amdahl effects] Your code needs to have enough parts that are
  parallel (see&nbsp;
<i>Eijkhout:IntroHPC</i>
). Sequential parts may be sped up
  by having them executed redundantly on each thread, since that keeps
  data locally.
<li>
[Dynamism] Creating a thread team takes time. In practice, a team
  is not created and deleted for each parallel region, but creating
  teams of different sizes, or recursize thread creation, may
  introduce overhead.
<li>
[Load imbalance] Even if your program is parallel, you need to
  worry about load balance. In the case of a parallel loop you can set
  the 
  the work, but may cause increased communication.
<li>
[Communication] Cache coherence causes communication. Threads
  should, as much as possible, refer to their own data.
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
Threads are likely to read from each other's data. That is
    largely unavoidable.
<li>
Threads writing to each other's data should be avoided: it may
    require synchronization, and it causes coherence traffic.
<li>
If threads can migrate, data that was local at one time is no
    longer local after migration.
<li>
Reading data from one socket that was allocated on another
    socket is inefficient; see section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/omp-affinity.html#First-touch">23.2</a>
.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<li>
[Affinity] Both data and execution threads can be bound to a
  specific locale to some extent. Using local data is more efficient
  than remote data, so you want to use local data, and minimize the extent to which data
  or execution can move.
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>
See the above points about phenomena that cause communication.
<li>
Section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/omp-affinity.html#Threadbinding">23.1.1</a>
 describes how you can specify the
    binding of threads to places. There can, but does not need, to be
    an effect on affinity. For instance, if an OpenMP thread can
    migrate between hardware threads, cached data will stay local.
    Leaving an OpenMP thread completely free to migrate can be
    advantageous for load balancing, but you should only do that if
    data affinity is of lesser importance.
<li>
Static loop schedules have a higher chance of using data that
    has affinity with the place of execution, but they are worse for
    load balancing. On the other hand, the 
    can aleviate some of the problems with static loop schedules.
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<li>
[Binding] You can choose to put OpenMP threads close together or
  to spread them apart. Having them close together makes sense if they
  use lots of shared data. Spreading them apart may increase
  bandwidth. (See the examples in section&nbsp;
<a href="http://pages.tacc.utexas.edu/~eijkhout/pcse/html/omp-affinity.html#Effectsofthreadbinding">23.1.2</a>
.)
<li>
[Synchronization] Barriers are a form of synchronization. They
  are expensive by themselves, and they expose load
  imbalance. Implicit barriers happen at the end of worksharing
  constructs; they can be removed with 
<tt>nowait</tt>
.
</p>

<p name="switchToTextMode">
  Critical sections imply a loss of parallelism, but they are also
  slow as they are realized through 
<i>operating system</i>
  functions. These are often quite costly, taking many thousands of
  cycles.  Critical sections should be used only if the parallel work
  far outweighs it.
</ul>
</description>
<!-- environment: description end embedded generator -->
<p name="switchToTextMode">

<h2><a id="Accelerators">26.5</a> Accelerators</h2>
<p name=crumbs>
crumb trail:  > <a href="openmp.html">openmp</a> > <a href="openmp.html#Accelerators">Accelerators</a>
</p>
</p>

<p name="switchToTextMode">
In OpenMP 4.0 there is support for offloading work to an
<i>accelerator</i>
<!-- index -->
or
<i>co-processor</i>
<!-- index -->
:
<!-- environment: lstlisting start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=lstlisting ]] -->
<lstlisting>
<pre>
#pragma omp target [clauses]
</pre>
</lstlisting>
<!-- environment: lstlisting end embedded generator -->
<p name="switchToTextMode">
with clauses such as
<!-- environment: itemize start embedded generator -->
</p>
<!-- environment block purpose: [[ environment=itemize ]] -->
<itemize>
<ul>
<!-- TranslatingLineGenerator itemize ['itemize'] -->
<li>

<tt>data</tt>
: place data
<li>

<tt>update</tt>
: make data consistent between host and device
</ul>
</itemize>
<!-- environment: itemize end embedded generator -->
<p name="switchToTextMode">

</div>
<a href="index.html">Back to Table of Contents</a>
