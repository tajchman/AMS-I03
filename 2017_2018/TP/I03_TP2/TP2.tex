\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usetheme[]{boxes}
\usecolortheme{seagull}
\usepackage{listings}

\begin{document}
\begin{frame}
	\frametitle{TP 2 :}
	\vfill
	\Large
	Points abord\'es :
	\vfill
	\begin{itemize}
		\item Programmation multi-threads
		\bigskip
		\item Exemples OpenMP
	\end{itemize}
	\vfill
\end{frame}

\begin{frame}
\frametitle{Rappels d'architecture}
	
	Exemple d\'ej\`a vu \`a la premi\`ere s\'eance de vue interne d'un n\oe ud (variable suivant le mod\`ele de processeur et la g\'en\'eration utilis\'ee):
	
	\begin{center}
		\includegraphics[scale=0.3]{architecture2}
	\end{center}

\end{frame}
	
\begin{frame}
	\begin{tabular}{lcl}
		Une machine &=& un ou plusieurs processeurs \\
		& + & une m\'emoire centrale ($\approx 10^{10}$ octets) partag\'ee \\
		& & (accessible directement par tous les processeurs)\\ \\
		Un processeur & = & un ou plusieurs c\oe urs \\
		& + & un ensemble de zones m\'emoire rapides ou\\
		& & mémoire cache ($\approx 10^{4}$ \`a $10^{6}$ octets)(caches) \\
		& & partag\'ees entre tous ou une partie des c\oe urs \\
		\\
		Un c\oe ur & = & une unit\'e de traitement capable d'ex\'ecuter \\
		& & un thread (une s\'equence d'instructions)
	\end{tabular}
\end{frame}

\begin{frame}
	\vfill
	En g\'en\'eral, une machine qui contient $N$ processeurs o\`u chaque processeur est compos\'e de $M$ c\oe urs peut ex\'ecuter au maximum $N\times M$ threads (s\'equences d'instructions) simultan\'ement.
	
	\vfill
	La gestion dans un programme de cet ensemble de threads s'appelle la programmation multi-threads
	\vfill
	
	Plusieurs outils logiciels permettent de faire cette gestion:
	\begin{itemize}
		\item pthreads
		\item OpenMP
		\item Threading Building Blocks
		\item ...
	\end{itemize}

	\vfill
	On utilisera ici l'outil OpenMP
\end{frame}

\begin{frame}
\frametitle{Pr\'eparation}

\vfill
\begin{enumerate}
	\item R\'ecup\'erer l'archive {\tt TP2.tar.gz} et extraire les fichiers.
	\item Ouvrir un terminal et se placer dans le r\'epertoire {\tt I03\_TP2} \break qui vient d'\^etre cr\'e\'e
	\item préparer la compilation du code du TP avec les commandes :
	\begin{quote}
		mkdir -p build\\
		cd build\\
		cmake ../src\\
		cd ..
	\end{quote}
	\item Se remettre dans le r\'epertoire {\tt I03\_TP2} et compiler:
	\begin{quote}
		make -C build VERBOSE=1
	\end{quote}
\end{enumerate}
\vfill	
\end{frame}

\begin{frame}
	\begin{enumerate}
		\setcounter{enumi}{4}
		\item Ex\'ecuter le code avec la commande:
		\begin{quote}
			./build/PoissonOpenMP
		\end{quote}
	\end{enumerate}
\end{frame}

\begin{frame}
	\textcolor{blue}{\bf Compl\'eter les fichiers sources pour utiliser la parall\'elisation OpenMP}
	
	\begin{itemize}
		\item Dans les fichiers du r\'epertoire src, rep\'erer la partie du code qui prend le plus de temps
		\item Ajouter une ``pragma" OpenMP pour essayer d'acc\'elerer cette partie du code (prendre comme exemple ce qui est fait dans le fichier values.cxx).
		\item Comparer en utilisant de 1 \`a 4 threads. (id\'ealement, on devrait aussi comparer avec la version sans OpenMP). 
	\end{itemize}
\end{frame}

\begin{frame}
	\textcolor{blue}{\bf Second exercice:}
        \vfill
	\begin{enumerate}
		\item Se mettre dans le r\'epertoire {\tt ExempleOpenMP}, qui contient un exemple simple: g\'en\'eration d'un ensemble de valeurs enti\`eres entre 0 et 19,
			comptage du pourcentage de valeurs \'egales \`a $k$ pour $0<=k<20$.
	        \item Parall\'eliser avec OpenMP
		\item Interpr\'eter les r\'esultats. S'ils ne sont pas ceux esp\'er\'es, revenir sur le point pr\'ec\'edent.
	\end{enumerate}
	\vfill
	\vfill
\end{frame}

\end{document}
